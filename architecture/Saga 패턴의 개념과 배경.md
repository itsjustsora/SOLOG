# Saga 패턴이 만들어진 이유

## 날짜
- 2026-02-09

## 🎯 오늘의 주제
- 분산 트랜잭션 환경에서 Saga 패턴이 등장한 배경 이해
- Saga 패턴을 구현 기법이 아닌 **설계 관점**에서 설명할 수 있도록 정리

> 본 문서는 Saga 패턴의 세부 구현보다는 **왜 이러한 접근 방식이 필요해졌는가**에 초점을 둔다.

---

## 1. 분산 트랜잭션의 한계

전통적인 트랜잭션 모델은 다음과 같은 전제를 기반으로 한다.

- 하나의 애플리케이션
- 하나의 데이터베이스
- 단일 트랜잭션 경계
- 커밋 또는 롤백을 통한 전체 성공 여부 판단

그러나 MSA 환경에서는 이러한 전제가 더 이상 자연스럽지 않다. 서비스와 데이터 저장소가 분리되면서, 시스템은 다음과 같은 특성을 갖게 된다.

- 네트워크를 통한 서비스 간 통신
- 단계별로 발생하는 부분 성공
- 실패 시점이 지연되거나 불확실한 상황
- 외부 시스템(API, 메시지 브로커 등)에 대한 의존성

이러한 환경에서는 **전체 작업을 하나의 트랜잭션으로 묶어 제어하려는 방식 자체가 구조적인 한계**를 가진다.

---

## 2. 2PC를 사용하지 않게 된 이유

2PC(Two-Phase Commit)는 분산 환경에서도 강한 정합성을 보장하기 위해 설계된 프로토콜이다.
이론적으로는 여러 노드가 모두 성공하거나 모두 실패하도록 맞출 수 있지만, 실무 환경에서는 다음과 같은 문제점이 반복적으로 나타난다.

- 장시간 락(Lock) 유지로 인한 성능 저하
- 네트워크 지연이 전체 트랜잭션 지연으로 확산
- 장애 발생 시 복구 절차의 복잡성 증가
- 일부 노드 장애가 전체 서비스 가용성에 영향을 미침

결과적으로 2PC는 정합성은 제공하지만 **가용성과 확장성을 크게 희생**하게 된다. 이러한 트레이드오프 때문에 MSA 환경에서는 2PC를 기본적인 선택지로 삼기 어렵다.

---

## 3. Saga라는 접근 방식의 등장

Saga는 분산 환경에서 트랜잭션을 확장하려는 시도에 대한 대안으로 등장했다.
Saga의 기본 전제는 다음과 같다.

- 각 서비스는 **자신의 데이터베이스에 대해서만 로컬 트랜잭션을 보장**한다.
- 전체 비즈니스 작업은 여러 개의 로컬 트랜잭션으로 분리된다.
- 중간 단계의 실패는 예외 상황이 아니라 **정상적인 상태**로 취급된다.

즉, Saga는 여러 작업을 하나의 트랜잭션으로 묶으려 하지 않고, **여러 단계의 작업 흐름을 관리하는 방식으로 일관성을 유지**한다.

---

## 4. Saga의 핵심 아이디어

Saga 패턴의 핵심 아이디어는 명확하다. Saga는 `모두 성공`을 강제하지 않는다. 대신, 이미 성공한 작업이 존재하는 상태에서 **이후 단계가 실패했을 때 무엇을 할 것인지**를 설계의 중심에 둔다.

이 과정에서 등장하는 개념이 **보상 트랜잭션(Compensating Transaction)** 이다. 보상 트랜잭션은 다음과 같은 특징을 가진다.

- DB 수준의 롤백이 아니다.
- 이미 수행된 비즈니스 행위에 대한 취소 또는 보정 동작이다.
- 완전한 원상복구를 보장하지 않을 수 있다.

이러한 특성 때문에 Saga 패턴은 즉시 정합성보다는 **최종적 일관성(Eventual Consistency)** 을 전제로 한다.

---

## 5. 도메인 관점에서의 적용

Saga 패턴은 다음과 같은 상황에서 특히 고려된다.

- 하나의 요청이 여러 서비스에 걸쳐 처리되는 경우
- 중간 단계마다 실패 가능성이 존재하는 경우
- 외부 시스템과의 연동이 비즈니스 흐름에 포함된 경우

이러한 환경에서는 트랜잭션을 무리하게 확장하려 하기보다, **실패를 전제로 한 흐름 설계가 더 안정적이고 현실적인 선택**이 된다.
