# 단일 트랜잭션(@Transactional)의 적용 범위와 MSA 환경에서의 한계
> DB 트랜잭션의 전제와 서비스 경계에 대한 정리

## 날짜
- 2026-02-02

## 🎯 문서 목적
- 단일 트랜잭션(@Transactional)이 보장하는 범위를 명확히 이해한다.
- 데이터베이스 트랜잭션이 성립하기 위한 전제 조건을 정리한다.
- MSA 환경에서 이 전제가 왜 깨지는지 구조적으로 설명한다.

---

## 1. 단일 트랜잭션의 전제

### 1.1 데이터베이스 트랜잭션의 기본 가정
데이터베이스 트랜잭션은 다음과 같은 전제를 기반으로 동작한다.

1) 트랜잭션의 경계(begin / commit / rollback)가 명확히 정의되어 있다.
2) 트랜잭션 내부의 데이터 변경은 논리적으로 하나의 작업 단위로 묶이며, 커밋 시점에 원자적으로 반영된다고 가정한다.
3) 트랜잭션의 모든 변경 사항은 **동일한 데이터베이스 내부 상태**를 대상으로 하며, 커밋 또는 롤백을 통해 **되돌릴 수 있다고 가정한다.**

이 전제는 트랜잭션이 **단일 데이터베이스 내부 상태를 관리하는 메커니즘**이라는 점을 전제로 한다.

<br>

### 1.2 ACID 모델에서의 Consistency와 Isolation

#### Consistency (일관성)
- 트랜잭션이 성공적으로 완료된 후 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- 여기서 일관성은 비즈니스 규칙의 완전한 충족을 의미하지 않으며, **스키마 제약 조건, 무결성 제약, 트리거 등 데이터베이스 수준의 규칙을 만족하는 상태**를 의미한다.
- 즉, **비즈니스 관점의 성공과 데이터베이스 관점의 일관성은 구분되어야 한다.**

#### Isolation (격리성)
- 동시에 실행되는 여러 트랜잭션 간에 중간 상태가 **어느 수준까지 노출될지를 제어하는 특성**이다.
- 격리 수준이 높을수록 동시성(throughput, 병렬성)은 낮아지고, 격리 수준이 낮을수록 dirty read, non-repeatable read, phantom read 등의 이상 현상이 발생할 수 있다.
- Isolation은 **동일한 데이터베이스 내부에서 실행되는 트랜잭션**을 전제로 한 개념이다.

> Consistency와 Isolation은 모두  
> **단일 데이터베이스라는 강한 전제 위에서 성립하는 특성**이다.

---

## 2. Spring `@Transactional`의 보장 범위

### 2.1 Spring 공식 문서 기준 정리

#### `@Transactional` 개요
- **적용 범위**
    - 클래스 레벨에 선언하면 해당 클래스의 public 메서드에 기본 적용된다.
    - 부모 클래스에는 자동 적용되지 않으며, 상속 구조에서는 명시적 선언이 필요하다.
- **작동 방식**
    - 내부적으로 `TransactionAttribute`로 변환되어 `PlatformTransactionManager`에 의해 처리된다.
    - 프록시 기반으로 동작한다.

<br>

#### 트랜잭션 관리 방식
- **스레드 기반 트랜잭션**
    - 일반적인 `PlatformTransactionManager`는 스레드에 트랜잭션을 바인딩한다.
    - 동일 스레드 내에서 수행되는 데이터 접근만 트랜잭션 범위에 포함된다.
    - 메서드 내부에서 새로 생성된 스레드에는 트랜잭션이 전파되지 않는다.
- **리액티브 트랜잭션**
    - `ReactiveTransactionManager`를 사용하며 Reactor Context를 기반으로 동작한다.
    - 리액티브 파이프라인 전체가 트랜잭션 범위로 관리된다.

<br>

#### 롤백 규칙
- 기본적으로 `RuntimeException`과 `Error` 발생 시 롤백된다.
- `rollbackFor`를 통해 특정 예외 타입에 대해 롤백을 명시할 수 있다.
- 문자열 기반 패턴 설정(`rollbackForClassName`)은 오작동 가능성이 있어 주의가 필요하다.

<br>

#### 주요 속성
- `propagation` : 트랜잭션 전파 방식 (기본값 REQUIRED)
- `isolation` : 격리 수준 (기본값 DEFAULT)
- `timeout` : 제한 시간
- `readOnly` : 읽기 전용 힌트
- `transactionManager` : 사용할 트랜잭션 매니저 지정

<br>

### 2.2 어디까지 트랜잭션인가?
- 기본적으로 프록시를 통해 외부에서 호출되는 public 메서드에 대해서만 트랜잭션이 시작된다.
- 같은 클래스 내부에서 `this.method()` 형태로 호출하면 트랜잭션 프록시가 적용되지 않는다.
- 전파 옵션에 따라 기존 트랜잭션에 참여하거나, 새로운 트랜잭션을 시작하거나, 트랜잭션 없이 실행될 수 있다.
- 이로 인해 **트랜잭션 경계는 코드 구조가 아니라 프록시 호출 구조에 의해 결정된다.**

---

## 3. 서비스 경계 확장 시 발생하는 문제

> 단일 트랜잭션의 서비스 경계를 무리하게 확장하면  
> 성능, 확장성, 결합도, 장애 전파, 모니터링 및 테스트 측면에서  
> 시스템 비용이 급격히 증가한다.

<br>

### 3.1 긴 트랜잭션
- 외부 API 호출, 파일 I/O, 다른 서비스 호출까지 트랜잭션에 포함하면 트랜잭션 지속 시간이 길어진다.
- 트랜잭션 지속 시간이 길어질수록 DB 커넥션과 락을 오래 점유하게 된다.
- 결과적으로 락 경합 증가, 처리량 감소, 응답 지연이 발생한다.

<br>

### 3.2 락 경합 및 데드락 위험 증가
- 긴 트랜잭션은 더 많은 레코드를 더 오래 점유한다.
- 여러 서비스가 서로의 데이터를 긴 트랜잭션으로 잡고 호출하면 교착 상태가 발생하기 쉬워진다.

<br>

### 3.3 불필요한 실패 전파 범위 증가
- 핵심 DB 업데이트는 성공했지만 부가적인 외부 호출 실패로 전체 트랜잭션이 롤백될 수 있다.
- 기술적으로는 성공했지만 비즈니스적으로는 실패, 혹은 그 반대의 상태가 발생할 수 있다.
- 가용성이 저하되고 장애 영향 범위가 확대된다.

<br>

### 3.4 서비스 결합도 증가
- 여러 서비스를 하나의 트랜잭션으로 묶으려는 순간 강한 결합이 발생한다.
- 독립 배포, 독립 확장, 장애 격리가 어려워진다.

<br>

### 3.5 분산 트랜잭션 문제
- 서비스 경계를 넘는 순간 여러 DB를 하나의 ACID 트랜잭션으로 묶기 위해서는 2PC가 필요하다.
- 2PC(2-Phase Commit)는 구현 및 운영 난이도가 높고 성능 비용이 크다.
- 클라우드 및 MSA 환경에서는 현실적으로 적용이 어렵다.

> MSA에서 서비스 경계란, 하나의 애플리케이션 프로세스와 그에 종속된 데이터베이스의 범위를 의미한다.
> 서비스 경계를 넘는다는 것은 다른 애플리케이션 프로세스나 다른 데이터베이스에 접근하는 것을 의미한다.

<br>

### 3.6 비즈니스 관점의 경계 왜곡
- 기술적 트랜잭션 경계가 비즈니스 성공 기준과 무관하게 확장될 수 있다.
- 보상 트랜잭션이나 이벤트로 처리하는 것이 적절한 단계까지 하나의 트랜잭션에 묶이면서 도메인 모델이 복잡해진다.

<br>

### 3.7 테스트 및 디버깅 복잡도 증가
- 트랜잭션 내부 단계가 많아질수록 실패 지점을 특정하기 어렵다.
- 부분 성공/부분 실패 시나리오를 재현하고 검증하기가 복잡해진다.

---

## 4. MSA 환경에서의 구조적 한계

### 4.1 단일 ACID 트랜잭션 적용의 어려움
- MSA에서는 서비스별로 데이터베이스가 분리된다.
- 전체 비즈니스 흐름은 여러 로컬 트랜잭션의 조합으로 표현된다.

> 로컬 트랜잭션이란 하나의 서비스가 소유한 데이터베이스에서만 적용되는 트랜잭션을 의미한다.
> MSA 환경에서는 각 서비스가 자신의 로컬 트랜잭션만 강하게 보장할 수 있다.

<br>

### 4.2 2PC의 한계
- 코디네이터 장애 시 가용성 저하
- 락 유지 시간 증가
- 확장성 저하
- 이기종 DB/클라우드 환경에서 제약 존재

> 2PC는 여러 데이터베이스를 하나의 트랜잭션으로 묶기 위한 분산 트랜잭션 프로토콜이다.
> 모든 참여자가 커밋 가능하다고 응답해야만 최종 커밋이 수행된다.
> 하지만 이 방식은 락 유지 시간 증가와 가용성 저하 문제로 MSA 환경에서는 잘 사용되지 않는다.

<br>

### 4.3 네트워크 및 서비스 장애로 인한 불확실성
- 네트워크 단절, 타임아웃, 부분 성공 등 분산 환경 특유의 실패가 존재한다.
- 단일 트랜잭션처럼 명확한 롤백이 어렵다.

<br>

### 4.4 강한 일관성과 가용성의 트레이드오프
- 분산 시스템에서는 강한 일관성을 유지할수록 가용성이 낮아진다.
- MSA는 일반적으로 즉시 일관성보다 최종 일관성을 선택한다.

> 최종 일관성이란 일정 시간이 지나면 시스템 전체가 일관된 상태에 도달함을 보장하는 개념이다.
> 즉, 중간 상태에서는 일시적인 불일치가 발생할 수 있다.

<br>

### 4.5 Saga 및 보상 트랜잭션의 복잡성
- Saga는 로컬 트랜잭션의 시퀀스와 보상 트랜잭션으로 구성된다.
- 보상 로직은 항상 이전 상태를 완벽히 복원하지 못한다.
- 설계 및 운영 복잡도가 높다.

> Saga 패턴은 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴이다.
> 여러 개의 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터 정합성을 맞춘다.
> 보상 트랜잭션은 어떤 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션이다.

<br>

### 4.6 일시적 불일치와 격리 문제
- 이벤트 기반 구조에서는 중간 상태가 외부에 노출될 수 있다.
- 여러 Saga가 동시에 실행되면 격리 문제가 발생할 수 있다.
- 조회 모델 분리(CQRS 등)에 대한 추가 설계가 필요해진다.

---

## 5. 단일 트랜잭션이 여전히 유효한 경우
- 단일 서비스 + 단일 데이터베이스
- 짧은 처리 시간
- 외부 I/O 없음
- 강한 즉시 일관성이 필요한 핵심 도메인 변경


