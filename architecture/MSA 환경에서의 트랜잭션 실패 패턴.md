# MSA 환경에서의 트랜잭션 실패 패턴

## 날짜
- 2026-02-03

## 🎯 오늘의 주제
- MSA 환경에서 발생하는 대표적인 트랜잭션 실패 패턴
- 부분 성공 / 부분 실패가 발생하는 구조
- 실제 도메인 기준 실패 시나리오 정리

---

## 1. 전형적인 트랜잭션/부분 실패 패턴
> MSA 환경에서는 “전체 비즈니스 트랜잭션”을 하나의 ACID 트랜잭션으로 묶을 수 없기 때문에,
다음과 같은 실패 패턴들이 반복적으로 등장한다.

<br>

### 1-1. 분산 트랜잭션(2PC) 중간 실패
#### 문제 상황
- 여러 서비스 또는 데이터베이스에 걸쳐 2PC(2-Phase Commit)를 사용한다.
- 커밋 단계에서 일부 참여자는 커밋에 성공하고, 일부는 타임아웃이나 네트워크 오류로 실패한다.
#### 핵심 문제
- 코디네이터 장애나 네트워크 파티션이 발생하면 한쪽은 `커밋 완료`로 인식하지만, 다른 쪽은 `커밋 상태를 알 수 없는 상태`가 된다.
- 이 상태에서는 어느 데이터가 최종 상태인지 판단하기 어렵다.
#### 결과
- 데이터 정합성이 깨지고, 시스템 전체 상태를 신뢰하기 어렵다.
- 장애 복구 과정에서 수동 개입이 필요해지는 경우가 많다.

> **💡 실무 포인트**
> 
> 이론적으로 가능한 방식이지만, 성능과 가용성 그리고 운영 복잡도 때문에 MSA 환경에서는 실제로 잘 사용되지 않는다.

<br>

### 1-2. Saga 진행 중 단계 실패
#### 문제 상황
- 여러 로컬 트랜잭션을 순차적으로 실행하는 Saga 패턴을 사용한다.
- N번째 단계까지는 성공했으나, N+1 단계에서 실패한다.

#### 핵심 문제
- 이전 단계에 대해 보상 트랜잭션(Compensation)을 호출해야 한다.
- 보상 호출 자체가 실패하거나, 중복 호출되어 또 다른 불일치를 만들 수 있다.

#### 결과
- 보상은 시도했지만 완전히 되돌려지지 않은 상태가 남는다.
- Saga가 길어질수록 실패 시 영향 범위가 커진다.

<br>

> **💡 중간 설명 | Saga가 길어진다는 말의 의미**
> 
> 여기서 길어진다는 표현은 시간이 오래 걸리는 것이 아니라 단계가 많아지는 것을 뜻한다. 
> 예를 들면, **["주문 생성", "결제 승인", "재고 차감", "배송 요청", "포인트 적립"]** 이런 단계가 많아질수록 실패 지점도 많아지고 보상해야 할 것도 많아져서 실패 지점을 파악하기가 점점 어려워진다.

<br>

### 1-3. 이벤트 드리븐 환경에서의 이벤트 손실/중복/지연
#### 문제 상황
- 메시지 브로커 장애 또는 네트워크 문제로 인해 아래 상황이 발생한다.
  - 이벤트 유실 (at-most-once)
  - 이벤트 중복 소비 (at-least-once)
  - 이벤트 지연 도착

> **💡 중간 설명 | `at-most-once`, `at-least-once` 이해하기**
> 
> - at-most-once
>   - 이벤트가 0번 또는 1번 처리될 수 있다
>   - 유실 가능성이 있으나 중복은 없다.
> - at-least-once
>   - 이벤트가 1번 이상 처리된다.
>   - 유실은 거의 없지만, 중복 처리가 가능하다.
> 
> 대부분의 메시지 시스템은 유실을 막기 위해 at-least-once를 선택하고, 대신 중복 처리를 애플리케이션에서 방어하게 된다.

#### 핵심 문제
- 이벤트 처리 순서가 깨질 수 있다.
- 이미 보상 로직이 실행된 이후에 이벤트가 도착하는 경우도 생긴다.

> **💡 중간 설명 | 보상 로직 실행 후 이벤트 도착하는 경우**
> 
> 예를 들어
> 1. 결제 이벤트가 발행된다.
> 2. 컨슈머 장애로 이벤트가 바로 처리되지 않는다.
> 3. 타임아웃으로 `결제 실패`로 판단하여 보상(환불)을 진행한다.
> 4. 나중에 지연된 결제 이벤트가 도착한다.
> 
> 이 경우 이미 환불이 완료되었는데 `결제 성공` 이벤트가 뒤늦게 처리되면서 상태가 다시 꼬일 수 있다. 

#### 결과
- 상태 전이가 꼬인다.
- 문제 발생 시 즉시 인지하기 어려운 `조용한 실패`가 발생한다.

<br>

### 1-4. 부분 커밋 및 장기 일관성 실패
#### 문제 상황
- 설계상 최종적 일관성(Eventual Consistency)을 허용한다.
- 재시도 로직이나 보상 로직에 버그 또는 누락이 존재한다.

#### 핵심 문제
- 잠깐의 불일치가 아닌 영구적인 불일치가 된다.
- 재시도 초과 후 DLQ에만 쌓이고, 실제 복구는 이루어지지 않는다.

#### 결과
- 운영 개입 없이는 상태가 회복되지 않는다.
- 데이터가 조용히 깨진 채로 남는다.

<br>

### 1.5 타임아웃 / 슬로우 서비스로 인한 중복 요청 처리
#### 문제 상황
- 호출자는 타임아웃으로 요청 실패를 판단하고 재시도한다.
- 실제 서비스는 첫 요청을 늦게 처리하고, 재시도 요청도 다시 처리한다.

#### 핵심 문제
- 요청의 중복 여부를 판단할 기준이 없다.
- Idempotency 키나 비즈니스 키로 방어하지 않았다.

#### 결과
- 중복 결제, 중복 대출, 중복 포인트 적립 등 치명적인 비즈니스 오류가 발생한다.

> 분산 환경에서는 요청은 도착했지만, 응답만 유실되는 경우가 존재한다.
> 그래서 재시도는 항상 이미 처리된 요청일 수 있다는 전제가 필요하다.

<br>

### 1.6 이벤트 순서 보장 실패로 인한 상태 꼬임
#### 문제 상황
- 동일 Aggregate에 대한 여러 이벤트가 순서가 바뀌어 소비된다.
- 컨슈머 스케일 아웃으로 인해 동시에 처리된다.

#### 핵심 문제
- 상태 전이가 순서를 가정하고 설계되었다.
- 이전 상태를 전제로 한 이벤트가 먼저 처리된다.

#### 결과
- `Cancelled → Paid` 같은 논리적으로 불가능한 상태가 만들어진다.

> **💡 중간 설명 | 왜 이런 일이 발생할까?**
> 
> 메시지 브로커는 이벤트 순서를 항상 보장해주지 않는다. 그래서 상태 머신은 현재 상태 + 이벤트 유효성 검사로 방어해야 한다.

<br>

### 1.7 Choreography 복잡성 증가로 인한 예측 불가능한 실패
> **💡 중간 설명 | Choreography란?**
> 
> Choreography는 중앙에서 전체 흐름을 제어하는 Orchestrator와 달리, 각 서비스가 이벤트를 보고 자신의 역할만 수행하는 방식이다. 
> 
> 이 방식에서는 
> - 전체 비즈니스 흐름을 아는 중앙 주체가 없고
> - 흐름이 여러 서비스의 이벤트 리스너에 분산된다.
> 
> 서비스 수가 늘어날수록 전체 흐름을 파악하기 어려워지고, 문제 발생 시 디버깅 난이도가 급격히 증가한다.


#### 문제 상황
- 이벤트 기반 Choreography 구조가 커진다.
- 서비스 간 의존 관계가 코드가 아니라 이벤트 흐름에 암묵적으로 얽힌다.

#### 핵심 문제
- 한 서비스 변경이 다른 서비스 실패 패턴을 유발한다.
- 에러의 시작 지점을 추적하기 어렵다.

#### 결과
- 장애 대응이 늦어지고, 부분 실패 상태가 장시간 방치된다.

---

## 2. 부분 성공/부분 실패가 만들어지는 구조적 원인 

### 2-1. 공유 트랜잭션 경계의 부재
- MSA에서는 각 서비스가 자신의 로컬 트랜잭션만 ACID로 관리한다.
- 전체 비즈니스 트랜잭션은 여러 로컬 트랜잭션의 조합으로 표현된다.
> 중간 실패 시, 이미 커밋된 단계는 되돌릴 수 없다.

<br>

### 2-2. 네트워크와 메시지 브로커라는 불안정한 매개체
- 호출 성공/실패 여부와 실제 처리 결과가 다를 수 있다.
- 응답 유실, 메시지 유실, 컨슈머 다운 등으로 인식 차이가 발생한다.
> 요청자는 실패로 인식하지만 실제로는 성공한 상태가 된다.

<br>

### 2-3. 비동기 이벤트 기반 설계의 특성
- 서비스 간 흐름이 느슨하게 연결된다.
- 한 단계 실패 시 이후 단계는 실행되지 않거나, 이미 실행된 단계를 되돌리기 어렵다.
> 각 서비스는 정상 처리했지만, 전체 흐름은 실패 상태가 된다.

<br>

### 2-4. 불완전한 보상 설계
- 모든 작업에 대해 완전한 보상은 현실적으로 불가능하다.
- 외부 시스템, 3rd party 연동은 특히 되돌리기 어렵다.

---

## 3.  도메인 예시별 대표 실패 시나리오

### 3-1. 이커머스
#### 결제 성공, 재고 실패
- Order 생성 -> Payment 승인 성공 -> Inventory 감소 호출 실패
- 결과 : 결제는 완료되었지만 재고가 확보되지 않아 주문이 중간 상태로 남는다.

#### 재고 성공, 배송/물류 실패
- 재고 예약/감소 후 배송사 API 호출 실패
- 결과 : 재고는 감소했지만 배송이 시작되지 않는다.

#### 주문 취소 Saga 중간 실패
- 배송 취소 및 재고 롤백 성공 후 결제 환불 단계 실패
- 결과 : `취소 처리 중/결제 환불 대기` 상태가 장시간 유지된다.

<br>

### 3-2. 금융/결제
#### 계좌 출금 성공, 입금 실패
- 출금 서비스는 트랜잭션 커밋 -> 입금 서비스 호출 실패
- 결과 : 사용자는 돈이 사라진 것처럼 인식한다.

#### 이체 Saga 보상 실패
- 출금 성공 -> 입금 실패 -> 출금 환급 실패
- 결과 : 출금은 성공, 입금 실패, 환급도 미처리되어 강한 일관성이 깨진다.

<br>

### 3-3. 코인
#### 내부 잔고 차감 성공, 온체인 전송 실패
[흐름]
1. 유저가 앱에서 `BTC 매수`를 선택한다.
2. 원화/USDT 등 내부 잔고를 차감한다.
3. 온체인 트랜잭션 생성을 생성하고 서명된 트랜잭션을 네트워크 노드들에 전파(브로드캐스트)한다.
4. 트랜잭션이 실패한다.

[결과]
- 내부 DB에는 `매수 요청/전송 요청 완료` 및 `잔고 차감` 상태이나 실제로는 온체인 트랜잭션이 발생하지 않았다.
- 재시도 로직이 잘못되면 같은 금액을 또 차감하고 다시 온체인 요청해 중복 차감이 가능하다.

[온체인 특이점]

네트워크 혼잡으로 트랜잭션이 매우 늦게 포함되는 경우, UX에는 "실패"처럼 보이다가 나중에 성공이 될 수도 있다.

<br>

#### 온체인 매수 성공, 내부 정산 실패
[흐름]
1. 유저 지갑에서 DEX(Decentralized Exchange, 탈중앙화 거래소)에 트랜잭션을 전송한다. (온체인 상에서 정확히 토큰 스왑 성공)
2. 플랫폼의 정산 서비스가 해당 트랜잭션을 감지하여 내부 DB에 `매수완료`, `잔고갱신`상태 업데이트를 시도한다.
3. 이벤트 수집이 실패한다. (내부 서비스 장애, 블록체인 노드 문제 등)

[결과]
- 온체인은 이미 토큰을 부여했지만 내부 DB에서는 `미체결/미정산` 상태가 된다.
- 유저는 온체인 지갑에서 토큰을 보는데 앱에서는 보이지 않기 때문에 다시 매수를 시도할 수 있다.

#### 온체인 매도 성공, 내부 원화/스테이블 입금 실패
[흐름]
1. 유저가 온체인 자산을 팔아 USDC/USDT 등을 받는다.
2. 내부 정산 서비스가 해당 온체인 수취 내역을 보고 내부 현금성 잔고(e.g. KRW 포인트) 증액을 시도한다.
3. 잔고 갱신이 실패한다. (내부 서비스 DB 장애, 환율 계산 오류, 타임아웃 등)

[결과]
- 온체인은 매도가 완료되어 유저의 토큰은 줄어들고 원화/스테이블은 늘어났다.
- 내부 DB에서는 `팔기 전 상태` 그대로이기 때문에 유저는 팔았는데 돈이 들어오지 않았다고 느낀다.

[온체인 특이점]

- 환율/가격이 시시각각 변하기 때문에 나중에 정산을 재시도할 때 어떤 시점의 가격을 기준으로 할지 정책적으로 정해져야 한다.


