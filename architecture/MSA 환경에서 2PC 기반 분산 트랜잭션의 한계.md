# MSA 환경에서 2PC 기반 분산 트랜잭션의 한계

## 날짜
- 2026-02-04

## 🎯 오늘의 주제
- 2PC(2-Phase Commit)의 개념과 한계
- 성능·가용성·운영 관점에서의 문제
- CAP 관점에서 본 트레이드오프

<br>

## 1. 2PC(Two-Phase Commit) 개념 정리

> 2PC는 분산 데이터베이스 환경에서 여러 노드에 걸친 트랜잭션의 원자성(Atomicity) 을 보장하기 위해 설계된 합의 프로토콜이다.
> 여러 참여자가 모두 성공하거나, 모두 실패하도록 맞추는 것이 목표다.
>
> 다만, 장애 상황에서는 트랜잭션이 블로킹(blocking) 상태에 빠질 수 있다는 구조적 한계를 가진다.

### 1-1. 핵심 역할 (Roles)
- **코디네이터 (Coordinator)**
  - 트랜잭션의 전체 흐름을 제어하는 중재자.
  - 모든 참여자에게 실행 여부를 묻고 최종 결정을 내린다.
- **참여자 (Participants)**
  - 실제 데이터가 저장된 각 서비스나 데이터베이스 노드.
  - 코디네이터의 지시에 따라 로컬 트랜잭션을 수행한다.

### 1-2. 단계별 프로세스 (Process)
2PC는 이름 그대로 두 단계의 과정을 거쳐 트랜잭션을 확정한다.

[1단계] Prepare 단계 (준비 단계 / Voting Phase)
- **준비 요청**
  - 코디네이터가 모든 참여자에게 “이 트랜잭션을 커밋할 준비가 되었는가?”라고 요청한다.
- **로컬 작업 수행**
  - 참여자는 실제 커밋을 하기 전, 필요한 모든 검증과 준비 작업을 수행한다.
  - 이 시점에 데이터에 락(Lock)을 걸어 다른 트랜잭션이 접근하지 못하게 한다.
- **응답**
  - 준비가 완료되면 VOTE_COMMIT(YES), 실패하면 VOTE_ABORT(NO)를 반환한다.

[2단계] Commit 단계 (확정 단계 / Decision Phase)
- **의사 결정**
  - 코디네이터가 모든 응답을 취합한다.
  - 전원 YES → GLOBAL_COMMIT
  - 하나라도 NO 또는 타임아웃 → GLOBAL_ROLLBACK
- **최종 실행**
  - 참여자는 명령에 따라 데이터를 실제로 반영하거나 되돌리고, 이후 락(Lock)을 해제한다.

<br>

### 1-3. 2PC의 묵시적 전제 조건
2PC가 정상적으로 동작하려면 다음과 같은 가정을 전제로 한다.

- **안정적인 저장소**
  - 코디네이터와 참여자는 자신의 상태를 비휘발성 저장소에 기록 장애 발생 시 복구할 수 있어야 한다.
- **네트워크 통신 가능**
  - 각 노드 간의 통신이 지연될 수는 있어도 결국에는 도달할 것이라는 가정이 필요하다.

<br>

## 2. 2PC를 현실에서 꺼리는 이유 (한계점)
### 2-1. 성능과 지연 문제 (Performance & Latency)
- **락(Lock) 점유 시간의 증가**
  - 모든 참여자가 `Prepare`를 완료할 때까지 락을 유지한다.
  - 네트워크 지연이나 느린 노드 하나가 전체 트랜잭션을 지연시킨다.
- **동기적 대기 (Synchronous Blocking) 구조**
  - 코디네이터가 최종 결정을 내릴 때까지 모든 참여자는 아무 작업도 할 수 없다.
  - 결과적으로 전체 처리량(TPS)이 급격히 감소한다.

### 2-2. 가용성 저하 및 장애 전파
- **In-doubt 상태 발생**
  - 코디네이터가 `Commit`결정을 내리기 직전에 장애가 발생하면, 참여자들은 커밋해야 하는지, 롤백해야 하는지 모르는 상태에 빠진다.
  - 이 상태에서는 락을 해제하지 못한다.
- **장애 전파**
  - 트랜잭션에 참여하는 서비스가 많을수록 단 하나의 장애가 전체 비즈니스 로직을 멈추게 만든다.
  - 서비스 간 독립성이 중요한 MSA에서는 치명적이다.

### 2-3. 장애 복구의 복잡도
- **자동 복구의 한계**
  - 블로킹 상태가 길어질 경우 자동 복구가 어려워진다.
- **수동 개입 필요**
  - 관리자가 각 노드의 로그를 직접 확인하고, 락 해제나 데이터 보정을 수행해야 하는 경우가 발생한다.
  - 운영 비용과 리스크가 매우 크다.

<br>

## 3. 실제 구현 방식들
### 3-1. 데이터베이스 자체 기능 (XA 트랜잭션)
- DB가 2PC 참여자 역할을 직접 수행한다.
- 강한 정합성이 제공된다.
- 설정과 운영이 매우 복잡하고, 클라우드/이기종 환경에 부적합하다.

### 3-2. 트랜잭션 매니저 (미들웨어)
- 애플리케이션 서버가 코디네이터 역할을 수행한다.
- 서버 장애 시 블로킹이 위험하다.
- 중앙 의존성이 커져 MSA 철학과 충돌한다.

### 3-3. 애플리케이션 레벨 직접 구현
- Prepare/Commit RPC를 직접 구현한다.
- 장애 및 복구 로직까지 모두 직접 관리해야 한다.
- 실무에서 거의 선택되지 않는다.

<br>

## 4. CAP 관점에서의 2PC
분산 시스템의 특성을 정의하는 CAP 이론으로 2PC를 분석하면 다음과 같다.

- **선택 (Consistency + Partition Tolerance)**
  - 분산 환경에서도 강한 정합성을 유지하려 한다.

> **💡 중간 설명 | Partition Tolerance**
> 네트워크 분할이 발생하더라도 시스템이 이를 전제로 동작할 수 있도록 설계하는 것을 의미한다.
분산 시스템에서는 선택이 아닌 필수 전제에 가깝다.

- **포기 (Availability)**
  - 하나의 노드만 응답하지 않아도 전체 트랜잭션이 멈춘다.

> **💡 중간 설명 | CAP 관점에서 본다는 것**
>
> 네트워크 분할이 발생한 상황을 전제로 시스템이 정합성과 가용성 중 어떤 가치를 우선 선택했는지를 분석하는 시각이다.
>
> - 예시 1.
    >   - 결제 승인 과정은 CAP 관점에서 가용성보다는 정합성을 우선한다. 일부 장애 상황에서는 요청을 실패 처리하여 중복 결제나 금액 불일치를 방지한다.
> - 예시 2.
    >   - 주문 체결 과정은 CAP 관점에서 정합성을 우선하여 설계된다. 네트워크 장애나 내부 오류 발생 시 체결 여부가 불확실한 상태로 노출되지 않도록 요청을 중단한다.
> - 예시 3.
    >   - 온체인 전송 요청은 CAP 관점에서 가용성을 우선할 수밖에 없다.
>   - 블록체인 네트워크는 외부 시스템으로, 요청 시점에 성공 여부를 즉시 확정할 수 없다.
>   - 따라서 즉각적인 정합성을 강제하지 않고 상태 전이를 통해 최종 결과를 확정한다.

<br>

## 5. 도메인 관점 정리
### Q. 왜 거래소/금융 서비스는 2PC를 싫어할까?
- **성능 한계**
  - 1초에 수만 건의 매매가 일어나는 환경에서 2단계 합의 구조는 지연 시간(Latency)을 감당할 수 없다.
- **연쇄 마비 위험**
  - 결제 모듈의 작은 장애가 주문, 조회, 정산 등 전체 서비스로 확산될 수 있다.
- **확장성 제한**
  - 서버가 늘어날수록 2PC의 복잡도는 기하급수적으로 증가해 선형적인 성능 확장이 어렵다.

<br>

> 2PC는 분산 환경에서 강한 정합성을 제공하지만, 그 대가로 블로킹, 지연, 그리고 장애 전파라는 구조적 비용을 지불하게 된다.
> MSA가 추구하는 가용성과 독립성과는 근본적으로 맞지 않는다.