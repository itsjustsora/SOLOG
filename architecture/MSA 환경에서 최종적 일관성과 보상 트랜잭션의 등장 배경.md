# MSA 환경에서 최종적 일관성과 보상 트랜잭션의 등장 배경

## 날짜
- 2026-02-05

## 🎯 오늘의 주제
- Eventually Consistent(최종적 일관성) 개념
- 보상 트랜잭션(Compensating Transaction) 아이디어
- 이벤트 기반으로 흐름이 바뀌는 이유

> 2PC 기반 분산 트랜잭션의 한계를 배경으로,  
> MSA 환경에서 정합성 전략이 어떻게 변화했는지를 살펴본다.

<br>

## 1. 최종적 일관성(Eventually Consistent)

### 1-1. 개념 및 배경
- 최종적 일관성은 분산 컴퓨팅 환경에서 **고가용성**을 확보하기 위해 채택되는 데이터 일관성 모델이다.
- 전통적인 RDBMS는 강한 일관성(Strong Consistency)을 전제로 하여, 데이터 변경 시 모든 노드에 즉각적인 동기화를 요구한다.
- 그러나 서비스가 독립된 데이터베이스를 가지는 MSA 환경에서는 네트워크 지연 및 장애 가능성으로 인해 실시간 동기화가 현실적으로 어렵다.

### 1-2. 핵심 원리: CAP 이론과 BASE
> 최종적 일관성은 네트워크 분할이 발생할 수 있다는 전제하에,  
> CAP 이론에서 일관성(Consistency)보다 가용성(Availability)과 분할 내성(Partition Tolerance)을 우선시하는 설계 선택의 결과이다.  
> 이는 ACID 트랜잭션 대신 BASE 철학을 따른다.

#### BASE
- **Basically Available**: 시스템은 장애 상황에서도 응답 가능한 상태를 유지한다.
- **Soft State**: 외부 입력이 없어도 시스템 상태는 변경될 수 있으며, 노드 간 일시적인 불일치가 허용된다.
- **Eventually Consistent**: 일정 시간이 지나면 모든 노드가 동일한 상태로 수렴한다.

<br>

## 2. 보상 트랜잭션(Compensating Transaction)

### 2-1. 분산 트랜잭션의 한계
> `MSA 환경에서 2PC 기반 분산 트랜잭션의 한계` 문서 참고

- MSA 환경에서는 여러 서비스에 걸친 비즈니스 로직을 하나의 로컬 트랜잭션으로 묶을 수 없다.
- 2PC는 이러한 문제를 해결하려는 시도였으나, 참여 노드에 락이 장시간 유지되고 장애가 전파되는 문제로 인해 현대적인 대규모 시스템에서는 지양된다.

### 2-2. 정의 및 작동 메커니즘
> 보상 트랜잭션은 특정 단계에서 실패가 발생했을 때,  
> 이전에 성공적으로 수행된 작업들을 **논리적으로 취소**하기 위해 실행되는 역방향 작업이다.

#### 비가역적 작업의 처리
- 데이터베이스 롤백은 물리적 상태를 이전으로 되돌리는 작업이다.
- 반면 보상 트랜잭션은 이미 커밋된 데이터를 수정하여 실패의 영향을 상쇄하는 **새로운 커밋**을 발생시킨다.

#### 멱등성(Idempotency) 확보
- 보상 트랜잭션은 네트워크 오류나 재시도로 인해 여러 번 실행될 수 있다.
- 따라서 동일한 보상 작업이 중복 실행되더라도 시스템 상태가 변하지 않도록 멱등성을 보장해야 한다.

<br>

## 3. 이벤트 기반 아키텍처(Event-Driven Architecture)

### 3-1. 흐름의 변화 이유
- 요청-응답 기반의 동기 호출은 서비스 간 결합도를 높이고 연쇄 장애를 유발한다.
- 이를 완화하기 위해, 서비스의 상태 변화를 **이벤트**로 정의하고 이를 비동기적으로 전파하는 방식이 도입되었다.

### 3-2. 시스템적 이점

#### 시간적 디커플링(Temporal Decoupling)
- 이벤트 발행자와 구독자는 동시에 실행될 필요가 없다.
- 메시지 브로커를 통해 이벤트가 영속화됨으로써 시스템의 회복탄력성이 향상된다.

#### 분산 트랜잭션 흐름의 표현
- 분산 환경에서는 트랜잭션을 하나의 커밋으로 묶는 대신,
- 이벤트의 성공/실패 흐름에 따라 다음 동작이나 보상 로직을 선택하는 방식으로 처리된다.

#### 데이터 정합성 유지
- 각 마이크로서비스는 이벤트를 통해 필요한 데이터를 수신하고,
- 이를 자신의 데이터 모델에 맞게 투영(Projection)함으로써 최종적 일관성을 달성한다.

<br>

## 4. 도메인 예시

> 즉시 정합성이 필요한지는  
> **해당 상태 전이가 되돌릴 수 있는지**,  
> 그리고 **불일치가 금전적·신뢰적 사고로 직결되는지**를 기준으로 판단한다.

### 4-1. 즉시 정합성(강한 일관성, Strong Consistency)이 필요한 경우

#### [코인]

**(1) 주문 체결 시 잔고 차감**
- 상황: 매수/매도 주문 체결 후 잔고 차감
- 이유:
    - 동일 자산에 대한 중복 사용(Double Spend) 위험
    - 잔고와 주문 상태 불일치는 즉각적인 금전 사고로 이어짐
- 판단:
    - 주문 체결과 잔고 차감은 하나의 원자적 성공 단위로 간주해야 함

**(2) 출금 요청 승인**
- 상황: 코인/원화 출금 승인 처리
- 이유:
    - 승인 이후에는 외부 시스템(블록체인/은행) 연동으로 롤백이 불가능

#### [대출]

**(1) 대출 실행(대출금 지급)**
- 상황: 대출 계약 완료 후 실제 자금 지급
- 이유:
    - 지급 여부와 대출 상태가 불일치하면 심각한 금융 사고 발생

**(2) 한도 차감 / 중복 대출 방지**
- 상황: 동일 고객의 동시 대출 요청
- 이유:
    - 한도 계산 및 차감은 경합 구간(Critical Section)
    - 중복 대출 발생 가능성

### 4-2. 최종적 일관성으로 괜찮은 경우

#### [코인]

**(1) 거래 내역 조회용 데이터 적재**
- 상황: 체결된 거래 내역을 조회/통계용 DB에 반영
- 이유:
    - 거래 체결 자체는 이미 확정
    - 조회 지연은 비즈니스에 치명적이지 않음

**(2) FDS(이상 거래 탐지) 이벤트 처리**
- 상황: 거래 발생 후 FDS 시스템으로 이벤트 전달
- 이유:
    - 사후 분석 성격
    - 지연 또는 재처리가 가능

#### [대출]

**(1) 대출 상태 변경 알림**
- 상황: 승인/실행 후 알림톡, 이메일 발송
- 이유:
    - 부가 기능이며 재시도 가능
    - 정합성 불일치가 금전 사고로 직결되지 않음
